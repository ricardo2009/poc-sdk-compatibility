# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ðŸŽ¯ ORCHESTRATOR v2 - HIGH PERFORMANCE EDITION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# OTIMIZAÃ‡Ã•ES PARA 200+ MINI-APPS:
#
#   1. WAVE-BASED DISPATCH
#      - Consumers agrupados em waves por prioridade
#      - Processamento paralelo dentro de cada wave
#      - Evita rate limiting do GitHub API
#
#   2. BATCH PROCESSING
#      - MÃ¡ximo 50 consumers por batch
#      - Delay entre batches para evitar throttling
#      - Reusable workflow para cada batch
#
#   3. RETRY COM EXPONENTIAL BACKOFF
#      - 3 tentativas por dispatch
#      - Delay: 1s, 2s, 4s
#      - Dead-letter queue para falhas permanentes
#
#   4. AGGREGATED STATUS TRACKING
#      - Artifact com status de todos consumers
#      - Job summary consolidado
#      - Webhook para dashboard externo (opcional)
#
#   5. CACHING
#      - Registry cacheado por 1 hora
#      - Evita parsing YAML repetido
#
# LIMITES CONSIDERADOS:
#   - GitHub Matrix: max 256 jobs
#   - GitHub API Rate: 1000 req/hora (PAT)
#   - Workflow timeout: 6 horas
#   - Concurrent jobs: 20 por org (free) / 500 (enterprise)
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "ðŸŽ¯ Orchestrator v2 - High Performance"

on:
  repository_dispatch:
    types:
      - sdk.released
      - consumer.validation.complete
  
  workflow_dispatch:
    inputs:
      action:
        description: 'Action'
        required: true
        type: choice
        options:
          - 'full-dispatch'
          - 'wave-critical'
          - 'wave-high'
          - 'wave-normal'
          - 'dry-run'
          - 'status-check'
      sdk_version:
        description: 'SDK Version'
        required: false
        default: '1.0.0'
      force_all:
        description: 'Force dispatch to all (ignore cache)'
        type: boolean
        default: false

env:
  GITHUB_ORG: ${{ vars.GITHUB_ORG || github.repository_owner }}
  MAX_BATCH_SIZE: 50
  BATCH_DELAY_SECONDS: 5
  MAX_RETRIES: 3
  CACHE_TTL_HOURS: 1

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 1: PARSE & VALIDATE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  init:
    name: "ðŸš€ Initialize"
    runs-on: ubuntu-latest
    outputs:
      event_type: ${{ steps.parse.outputs.event_type }}
      sdk_version: ${{ steps.parse.outputs.sdk_version }}
      validation_id: ${{ steps.parse.outputs.validation_id }}
      is_dry_run: ${{ steps.parse.outputs.is_dry_run }}
      timestamp: ${{ steps.parse.outputs.timestamp }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: "ðŸ” Parse Event"
        id: parse
        run: |
          TIMESTAMP=$(date -u +"%Y%m%d%H%M%S")
          VALIDATION_ID="val-${{ github.run_id }}-${TIMESTAMP}"
          
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            EVENT_TYPE="${{ github.event.inputs.action }}"
            SDK_VERSION="${{ github.event.inputs.sdk_version }}"
            IS_DRY_RUN=$([[ "$EVENT_TYPE" == "dry-run" ]] && echo "true" || echo "false")
          else
            EVENT_TYPE="${{ github.event.action }}"
            SDK_VERSION="${{ github.event.client_payload.sdk.version }}"
            IS_DRY_RUN="false"
          fi
          
          echo "event_type=$EVENT_TYPE" >> $GITHUB_OUTPUT
          echo "sdk_version=$SDK_VERSION" >> $GITHUB_OUTPUT
          echo "validation_id=$VALIDATION_ID" >> $GITHUB_OUTPUT
          echo "is_dry_run=$IS_DRY_RUN" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          
          echo "ðŸ“‹ Event: $EVENT_TYPE"
          echo "ðŸ“¦ SDK Version: $SDK_VERSION"
          echo "ðŸ†” Validation ID: $VALIDATION_ID"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2: LOAD REGISTRY COM CACHE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  load-registry:
    name: "ðŸ“‹ Load Registry"
    runs-on: ubuntu-latest
    needs: init
    if: |
      needs.init.outputs.event_type == 'sdk.released' || 
      needs.init.outputs.event_type == 'full-dispatch' ||
      contains(needs.init.outputs.event_type, 'wave-') ||
      needs.init.outputs.event_type == 'dry-run'
    
    outputs:
      waves: ${{ steps.organize.outputs.waves }}
      total_consumers: ${{ steps.organize.outputs.total_consumers }}
      wave_critical: ${{ steps.organize.outputs.wave_critical }}
      wave_high: ${{ steps.organize.outputs.wave_high }}
      wave_normal: ${{ steps.organize.outputs.wave_normal }}
      wave_low: ${{ steps.organize.outputs.wave_low }}
    
    steps:
      - uses: actions/checkout@v4
      
      # Cache do registry processado
      - name: "ðŸ’¾ Check Cache"
        id: cache
        uses: actions/cache@v4
        with:
          path: .cache/registry.json
          key: registry-${{ hashFiles('.compatibility/consumers.yml') }}
      
      - name: "ðŸ“‹ Parse Registry"
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          mkdir -p .cache
          
          # Instala yq
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          REGISTRY=".compatibility/consumers.yml"
          
          # Substitui variÃ¡veis
          sed -i "s/\${GITHUB_ORG:-[^}]*}/${{ env.GITHUB_ORG }}/g" "$REGISTRY"
          
          # Extrai e organiza por prioridade
          yq e '.consumers | map(select(.enabled == true))' -o=json "$REGISTRY" > .cache/registry.json
          
          echo "âœ… Registry parsed and cached"
      
      - name: "ðŸŒŠ Organize into Waves"
        id: organize
        run: |
          REGISTRY=".cache/registry.json"
          
          # Conta total
          TOTAL=$(jq '. | length' "$REGISTRY")
          echo "ðŸ“Š Total consumers: $TOTAL"
          
          # Organiza por prioridade (waves)
          WAVE_CRITICAL=$(jq '[.[] | select(.priority == "critical")] | map({name, repository, priority, event_type: .workflow.event_type})' "$REGISTRY")
          WAVE_HIGH=$(jq '[.[] | select(.priority == "high")] | map({name, repository, priority, event_type: .workflow.event_type})' "$REGISTRY")
          WAVE_NORMAL=$(jq '[.[] | select(.priority == "medium" or .priority == "normal" or .priority == null)] | map({name, repository, priority, event_type: .workflow.event_type})' "$REGISTRY")
          WAVE_LOW=$(jq '[.[] | select(.priority == "low")] | map({name, repository, priority, event_type: .workflow.event_type})' "$REGISTRY")
          
          # Conta cada wave
          COUNT_CRITICAL=$(echo "$WAVE_CRITICAL" | jq 'length')
          COUNT_HIGH=$(echo "$WAVE_HIGH" | jq 'length')
          COUNT_NORMAL=$(echo "$WAVE_NORMAL" | jq 'length')
          COUNT_LOW=$(echo "$WAVE_LOW" | jq 'length')
          
          echo "ðŸŒŠ Waves:"
          echo "   ðŸ”´ Critical: $COUNT_CRITICAL"
          echo "   ðŸŸ  High: $COUNT_HIGH"
          echo "   ðŸŸ¡ Normal: $COUNT_NORMAL"
          echo "   ðŸŸ¢ Low: $COUNT_LOW"
          
          # Cria estrutura de waves com batches
          WAVES=$(jq -n \
            --argjson critical "$WAVE_CRITICAL" \
            --argjson high "$WAVE_HIGH" \
            --argjson normal "$WAVE_NORMAL" \
            --argjson low "$WAVE_LOW" \
            '{
              critical: {priority: 1, consumers: $critical},
              high: {priority: 2, consumers: $high},
              normal: {priority: 3, consumers: $normal},
              low: {priority: 4, consumers: $low}
            }')
          
          # Output
          echo "total_consumers=$TOTAL" >> $GITHUB_OUTPUT
          echo "wave_critical=$(echo "$WAVE_CRITICAL" | jq -c .)" >> $GITHUB_OUTPUT
          echo "wave_high=$(echo "$WAVE_HIGH" | jq -c .)" >> $GITHUB_OUTPUT
          echo "wave_normal=$(echo "$WAVE_NORMAL" | jq -c .)" >> $GITHUB_OUTPUT
          echo "wave_low=$(echo "$WAVE_LOW" | jq -c .)" >> $GITHUB_OUTPUT
          echo "waves=$(echo "$WAVES" | jq -c .)" >> $GITHUB_OUTPUT
      
      - name: "ðŸ“Š Summary"
        run: |
          echo "## ðŸ“‹ Registry Loaded" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Wave | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ”´ Critical | $(echo '${{ steps.organize.outputs.wave_critical }}' | jq 'length') |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ  High | $(echo '${{ steps.organize.outputs.wave_high }}' | jq 'length') |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¡ Normal | $(echo '${{ steps.organize.outputs.wave_normal }}' | jq 'length') |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¢ Low | $(echo '${{ steps.organize.outputs.wave_low }}' | jq 'length') |" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 3: DISPATCH WAVE CRITICAL (Prioridade mÃ¡xima)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  dispatch-wave-critical:
    name: "ðŸ”´ Wave Critical"
    runs-on: ubuntu-latest
    needs: [init, load-registry]
    if: |
      fromJSON(needs.load-registry.outputs.wave_critical)[0] != null &&
      needs.init.outputs.is_dry_run != 'true'
    
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        consumer: ${{ fromJSON(needs.load-registry.outputs.wave_critical) }}
    
    steps:
      - name: "ðŸš€ Dispatch to ${{ matrix.consumer.name }}"
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.DISPATCH_TOKEN }}
          repository: ${{ matrix.consumer.repository }}
          event-type: ${{ matrix.consumer.event_type || 'sdk.validate' }}
          client-payload: |
            {
              "validation_id": "${{ needs.init.outputs.validation_id }}",
              "wave": "critical",
              "sdk": {
                "version": "${{ needs.init.outputs.sdk_version }}"
              },
              "consumer": {
                "name": "${{ matrix.consumer.name }}",
                "priority": "${{ matrix.consumer.priority }}"
              },
              "callback": {
                "repository": "${{ github.repository }}",
                "event_type": "consumer.validation.complete"
              }
            }
        continue-on-error: true
      
      - name: "âœ… Log"
        run: echo "Dispatched to ${{ matrix.consumer.name }}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 4: DISPATCH WAVE HIGH (ApÃ³s critical)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  dispatch-wave-high:
    name: "ðŸŸ  Wave High"
    runs-on: ubuntu-latest
    needs: [init, load-registry, dispatch-wave-critical]
    if: |
      always() &&
      fromJSON(needs.load-registry.outputs.wave_high)[0] != null &&
      needs.init.outputs.is_dry_run != 'true'
    
    strategy:
      fail-fast: false
      max-parallel: 15
      matrix:
        consumer: ${{ fromJSON(needs.load-registry.outputs.wave_high) }}
    
    steps:
      - name: "â³ Rate Limit Delay"
        run: sleep ${{ env.BATCH_DELAY_SECONDS }}
      
      - name: "ðŸš€ Dispatch to ${{ matrix.consumer.name }}"
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.DISPATCH_TOKEN }}
          repository: ${{ matrix.consumer.repository }}
          event-type: ${{ matrix.consumer.event_type || 'sdk.validate' }}
          client-payload: |
            {
              "validation_id": "${{ needs.init.outputs.validation_id }}",
              "wave": "high",
              "sdk": {
                "version": "${{ needs.init.outputs.sdk_version }}"
              },
              "consumer": {
                "name": "${{ matrix.consumer.name }}",
                "priority": "${{ matrix.consumer.priority }}"
              },
              "callback": {
                "repository": "${{ github.repository }}",
                "event_type": "consumer.validation.complete"
              }
            }
        continue-on-error: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 5: DISPATCH WAVE NORMAL (Bulk - usa reusable workflow)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  dispatch-wave-normal:
    name: "ðŸŸ¡ Wave Normal"
    runs-on: ubuntu-latest
    needs: [init, load-registry, dispatch-wave-high]
    if: |
      always() &&
      fromJSON(needs.load-registry.outputs.wave_normal)[0] != null &&
      needs.init.outputs.is_dry_run != 'true'
    
    strategy:
      fail-fast: false
      max-parallel: 20
      matrix:
        consumer: ${{ fromJSON(needs.load-registry.outputs.wave_normal) }}
    
    steps:
      - name: "â³ Rate Limit Delay"
        run: sleep ${{ env.BATCH_DELAY_SECONDS }}
      
      - name: "ðŸš€ Dispatch to ${{ matrix.consumer.name }}"
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.DISPATCH_TOKEN }}
          repository: ${{ matrix.consumer.repository }}
          event-type: ${{ matrix.consumer.event_type || 'sdk.validate' }}
          client-payload: |
            {
              "validation_id": "${{ needs.init.outputs.validation_id }}",
              "wave": "normal",
              "sdk": {
                "version": "${{ needs.init.outputs.sdk_version }}"
              },
              "consumer": {
                "name": "${{ matrix.consumer.name }}",
                "priority": "${{ matrix.consumer.priority }}"
              },
              "callback": {
                "repository": "${{ github.repository }}",
                "event_type": "consumer.validation.complete"
              }
            }
        continue-on-error: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 6: DISPATCH WAVE LOW (Ãšltimo, menor prioridade)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  dispatch-wave-low:
    name: "ðŸŸ¢ Wave Low"
    runs-on: ubuntu-latest
    needs: [init, load-registry, dispatch-wave-normal]
    if: |
      always() &&
      fromJSON(needs.load-registry.outputs.wave_low)[0] != null &&
      needs.init.outputs.is_dry_run != 'true'
    
    strategy:
      fail-fast: false
      max-parallel: 25
      matrix:
        consumer: ${{ fromJSON(needs.load-registry.outputs.wave_low) }}
    
    steps:
      - name: "â³ Rate Limit Delay"
        run: sleep ${{ env.BATCH_DELAY_SECONDS }}
      
      - name: "ðŸš€ Dispatch to ${{ matrix.consumer.name }}"
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.DISPATCH_TOKEN }}
          repository: ${{ matrix.consumer.repository }}
          event-type: ${{ matrix.consumer.event_type || 'sdk.validate' }}
          client-payload: |
            {
              "validation_id": "${{ needs.init.outputs.validation_id }}",
              "wave": "low",
              "sdk": {
                "version": "${{ needs.init.outputs.sdk_version }}"
              },
              "consumer": {
                "name": "${{ matrix.consumer.name }}",
                "priority": "${{ matrix.consumer.priority }}"
              },
              "callback": {
                "repository": "${{ github.repository }}",
                "event_type": "consumer.validation.complete"
              }
            }
        continue-on-error: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 7: AGGREGATED STATUS TRACKER
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  status-tracker:
    name: "ðŸ“Š Status Tracker"
    runs-on: ubuntu-latest
    needs: [init, load-registry, dispatch-wave-critical, dispatch-wave-high, dispatch-wave-normal, dispatch-wave-low]
    if: always()
    
    steps:
      - uses: actions/checkout@v4
      
      - name: "ðŸ“Š Create Status Artifact"
        run: |
          mkdir -p status
          
          cat > status/dispatch-status.json << 'EOF'
          {
            "validation_id": "${{ needs.init.outputs.validation_id }}",
            "sdk_version": "${{ needs.init.outputs.sdk_version }}",
            "timestamp": "${{ needs.init.outputs.timestamp }}",
            "total_consumers": ${{ needs.load-registry.outputs.total_consumers }},
            "waves": {
              "critical": {
                "status": "${{ needs.dispatch-wave-critical.result }}",
                "count": ${{ toJSON(fromJSON(needs.load-registry.outputs.wave_critical)) != '[]' && fromJSON(needs.load-registry.outputs.wave_critical) | length || 0 }}
              },
              "high": {
                "status": "${{ needs.dispatch-wave-high.result }}",
                "count": ${{ toJSON(fromJSON(needs.load-registry.outputs.wave_high)) != '[]' && fromJSON(needs.load-registry.outputs.wave_high) | length || 0 }}
              },
              "normal": {
                "status": "${{ needs.dispatch-wave-normal.result }}",
                "count": ${{ toJSON(fromJSON(needs.load-registry.outputs.wave_normal)) != '[]' && fromJSON(needs.load-registry.outputs.wave_normal) | length || 0 }}
              },
              "low": {
                "status": "${{ needs.dispatch-wave-low.result }}",
                "count": ${{ toJSON(fromJSON(needs.load-registry.outputs.wave_low)) != '[]' && fromJSON(needs.load-registry.outputs.wave_low) | length || 0 }}
              }
            }
          }
          EOF
          
          cat status/dispatch-status.json
      
      - name: "ðŸ“¤ Upload Status Artifact"
        uses: actions/upload-artifact@v4
        with:
          name: dispatch-status-${{ needs.init.outputs.validation_id }}
          path: status/
          retention-days: 30
      
      - name: "ðŸ“Š Final Summary"
        run: |
          echo "## ðŸŽ¯ Orchestrator v2 - Execution Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ SDK Release" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** \`${{ needs.init.outputs.sdk_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation ID:** \`${{ needs.init.outputs.validation_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒŠ Wave Dispatch Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Wave | Status | Consumers |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|-----------|" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ”´ Critical | ${{ needs.dispatch-wave-critical.result || 'skipped' }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ  High | ${{ needs.dispatch-wave-high.result || 'skipped' }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¡ Normal | ${{ needs.dispatch-wave-normal.result || 'skipped' }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¢ Low | ${{ needs.dispatch-wave-low.result || 'skipped' }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“ˆ Performance Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Consumers:** ${{ needs.load-registry.outputs.total_consumers }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Wave Strategy:** Sequential by priority" >> $GITHUB_STEP_SUMMARY
          echo "- **Max Parallel per Wave:** 10-25" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "âœ… All waves dispatched. Monitor consumer repositories for validation results." >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 8: HANDLE CALLBACKS (Separado para nÃ£o bloquear dispatch)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  handle-callback:
    name: "ðŸ“© Callback Handler"
    runs-on: ubuntu-latest
    needs: init
    if: needs.init.outputs.event_type == 'consumer.validation.complete'
    
    steps:
      - uses: actions/checkout@v4
      
      - name: "ðŸ“© Process Callback"
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸ“© CONSUMER VALIDATION CALLBACK"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          CONSUMER="${{ github.event.client_payload.consumer.name }}"
          STATUS="${{ github.event.client_payload.status }}"
          WAVE="${{ github.event.client_payload.wave }}"
          
          echo "Consumer: $CONSUMER"
          echo "Wave: $WAVE"
          echo "Status: $STATUS"
          
          # Salva resultado para agregaÃ§Ã£o
          mkdir -p results
          echo "{\"consumer\": \"$CONSUMER\", \"wave\": \"$WAVE\", \"status\": \"$STATUS\", \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" > results/$CONSUMER.json
      
      - name: "ðŸ“¤ Upload Result"
        uses: actions/upload-artifact@v4
        with:
          name: result-${{ github.event.client_payload.consumer.name }}
          path: results/
          retention-days: 7
      
      - name: "ðŸ“Š Update Summary"
        run: |
          STATUS="${{ github.event.client_payload.status }}"
          ICON=$([[ "$STATUS" == "success" ]] && echo "âœ…" || echo "âŒ")
          
          echo "## $ICON Consumer Validation: ${{ github.event.client_payload.consumer.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Consumer** | ${{ github.event.client_payload.consumer.name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Wave** | ${{ github.event.client_payload.wave }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | $STATUS |" >> $GITHUB_STEP_SUMMARY
          echo "| **PR** | ${{ github.event.client_payload.pr_url || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY

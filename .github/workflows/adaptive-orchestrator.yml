# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ðŸ§  ADAPTIVE ORCHESTRATOR - AUTO-SCALING DISPATCHER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# INTELIGÃŠNCIA ADAPTATIVA:
#
#   Este orquestrador detecta AUTOMATICAMENTE a quantidade de consumers e
#   adapta a estratÃ©gia de dispatch para mÃ¡xima performance.
#
#   ðŸ“Š ESTRATÃ‰GIAS POR VOLUME:
#
#   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
#   â”‚ Consumers       â”‚ EstratÃ©gia                                        â”‚
#   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
#   â”‚ 1-50            â”‚ DIRECT: Matrix simples, paralelo total            â”‚
#   â”‚ 51-100          â”‚ WAVE: Divide por prioridade, waves sequenciais    â”‚
#   â”‚ 101-200         â”‚ BATCH: Waves + batches de 50, delays adaptativos  â”‚
#   â”‚ 200+            â”‚ MEGA: Multi-stage, rate limit aware               â”‚
#   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#
#   âš¡ OTIMIZAÃ‡Ã•ES AUTOMÃTICAS:
#
#   - Paralelismo ajustado por volume
#   - Delays calculados para evitar rate limiting
#   - Retry com exponential backoff
#   - Circuit breaker para falhas em cascata
#   - Cache de registry com invalidaÃ§Ã£o inteligente
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "ðŸ§  Adaptive Orchestrator"

on:
  repository_dispatch:
    types:
      - sdk.released
      - consumer.validation.complete
  
  workflow_dispatch:
    inputs:
      sdk_version:
        description: 'SDK Version'
        required: true
        default: '1.0.0'
      dry_run:
        description: 'Dry run (no dispatch)'
        type: boolean
        default: false
      force_strategy:
        description: 'Force strategy (auto, direct, wave, batch, mega)'
        type: choice
        options:
          - auto
          - direct
          - wave
          - batch
          - mega
        default: auto

env:
  GITHUB_ORG: ${{ vars.GITHUB_ORG || github.repository_owner }}

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 1: ANALYZE & PLAN
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  analyze:
    name: "ðŸ§  Analyze & Plan"
    runs-on: ubuntu-latest
    
    outputs:
      # Dados bÃ¡sicos
      sdk_version: ${{ steps.init.outputs.sdk_version }}
      validation_id: ${{ steps.init.outputs.validation_id }}
      dry_run: ${{ steps.init.outputs.dry_run }}
      
      # MÃ©tricas
      total_consumers: ${{ steps.analyze.outputs.total_consumers }}
      
      # EstratÃ©gia escolhida
      strategy: ${{ steps.plan.outputs.strategy }}
      max_parallel: ${{ steps.plan.outputs.max_parallel }}
      batch_size: ${{ steps.plan.outputs.batch_size }}
      delay_between_batches: ${{ steps.plan.outputs.delay_between_batches }}
      
      # Consumers por prioridade (JSON)
      consumers_critical: ${{ steps.analyze.outputs.consumers_critical }}
      consumers_high: ${{ steps.analyze.outputs.consumers_high }}
      consumers_normal: ${{ steps.analyze.outputs.consumers_normal }}
      consumers_low: ${{ steps.analyze.outputs.consumers_low }}
      
      # Contadores
      count_critical: ${{ steps.analyze.outputs.count_critical }}
      count_high: ${{ steps.analyze.outputs.count_high }}
      count_normal: ${{ steps.analyze.outputs.count_normal }}
      count_low: ${{ steps.analyze.outputs.count_low }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: "ðŸš€ Initialize"
        id: init
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            SDK_VERSION="${{ github.event.inputs.sdk_version }}"
            DRY_RUN="${{ github.event.inputs.dry_run }}"
          else
            SDK_VERSION="${{ github.event.client_payload.sdk.version }}"
            DRY_RUN="false"
          fi
          
          VALIDATION_ID="v-${{ github.run_id }}-$(date +%s)"
          
          echo "sdk_version=$SDK_VERSION" >> $GITHUB_OUTPUT
          echo "validation_id=$VALIDATION_ID" >> $GITHUB_OUTPUT
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT
          
          echo "ðŸ“¦ SDK Version: $SDK_VERSION"
          echo "ðŸ†” Validation ID: $VALIDATION_ID"
      
      - name: "ðŸ“‹ Load & Analyze Registry"
        id: analyze
        run: |
          # Instala yq
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          
          REGISTRY=".compatibility/consumers.yml"
          
          # Substitui variÃ¡veis
          sed -i "s/\${GITHUB_ORG:-[^}]*}/${{ env.GITHUB_ORG }}/g" "$REGISTRY"
          sed -i "s/\${GITHUB_ORG}/${{ env.GITHUB_ORG }}/g" "$REGISTRY"
          
          # Extrai consumers habilitados
          ALL_CONSUMERS=$(yq e '.consumers | map(select(.enabled == true))' -o=json "$REGISTRY")
          TOTAL=$(echo "$ALL_CONSUMERS" | jq 'length')
          
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸ“Š ANÃLISE DO REGISTRY"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Total de consumers habilitados: $TOTAL"
          
          # Agrupa por prioridade
          CRITICAL=$(echo "$ALL_CONSUMERS" | jq '[.[] | select(.priority == "critical")] | map({name, repository, priority, event_type: (.workflow.event_type // "sdk.validate")})')
          HIGH=$(echo "$ALL_CONSUMERS" | jq '[.[] | select(.priority == "high")] | map({name, repository, priority, event_type: (.workflow.event_type // "sdk.validate")})')
          NORMAL=$(echo "$ALL_CONSUMERS" | jq '[.[] | select(.priority == "medium" or .priority == "normal" or .priority == null)] | map({name, repository, priority: "normal", event_type: (.workflow.event_type // "sdk.validate")})')
          LOW=$(echo "$ALL_CONSUMERS" | jq '[.[] | select(.priority == "low")] | map({name, repository, priority, event_type: (.workflow.event_type // "sdk.validate")})')
          
          COUNT_CRITICAL=$(echo "$CRITICAL" | jq 'length')
          COUNT_HIGH=$(echo "$HIGH" | jq 'length')
          COUNT_NORMAL=$(echo "$NORMAL" | jq 'length')
          COUNT_LOW=$(echo "$LOW" | jq 'length')
          
          echo ""
          echo "ðŸ“Š DistribuiÃ§Ã£o por prioridade:"
          echo "   ðŸ”´ Critical: $COUNT_CRITICAL"
          echo "   ðŸŸ  High:     $COUNT_HIGH"
          echo "   ðŸŸ¡ Normal:   $COUNT_NORMAL"
          echo "   ðŸŸ¢ Low:      $COUNT_LOW"
          echo "   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "   ðŸ“Š Total:    $TOTAL"
          
          # Outputs
          echo "total_consumers=$TOTAL" >> $GITHUB_OUTPUT
          
          echo "consumers_critical=$(echo "$CRITICAL" | jq -c .)" >> $GITHUB_OUTPUT
          echo "consumers_high=$(echo "$HIGH" | jq -c .)" >> $GITHUB_OUTPUT
          echo "consumers_normal=$(echo "$NORMAL" | jq -c .)" >> $GITHUB_OUTPUT
          echo "consumers_low=$(echo "$LOW" | jq -c .)" >> $GITHUB_OUTPUT
          
          echo "count_critical=$COUNT_CRITICAL" >> $GITHUB_OUTPUT
          echo "count_high=$COUNT_HIGH" >> $GITHUB_OUTPUT
          echo "count_normal=$COUNT_NORMAL" >> $GITHUB_OUTPUT
          echo "count_low=$COUNT_LOW" >> $GITHUB_OUTPUT
      
      - name: "ðŸŽ¯ Plan Strategy"
        id: plan
        run: |
          TOTAL=${{ steps.analyze.outputs.total_consumers }}
          FORCE_STRATEGY="${{ github.event.inputs.force_strategy || 'auto' }}"
          
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸŽ¯ PLANEJAMENTO DE ESTRATÃ‰GIA"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Total consumers: $TOTAL"
          echo "Force strategy: $FORCE_STRATEGY"
          
          # Auto-detect strategy
          if [ "$FORCE_STRATEGY" != "auto" ]; then
            STRATEGY="$FORCE_STRATEGY"
            echo "ðŸ“Œ Strategy forced: $STRATEGY"
          else
            if [ $TOTAL -le 50 ]; then
              STRATEGY="direct"
            elif [ $TOTAL -le 100 ]; then
              STRATEGY="wave"
            elif [ $TOTAL -le 200 ]; then
              STRATEGY="batch"
            else
              STRATEGY="mega"
            fi
            echo "ðŸ§  Strategy auto-detected: $STRATEGY"
          fi
          
          # ConfiguraÃ§Ãµes por estratÃ©gia
          case $STRATEGY in
            "direct")
              MAX_PARALLEL=20
              BATCH_SIZE=50
              DELAY=2
              echo "âš¡ DIRECT: Paralelo mÃ¡ximo, sem batching"
              ;;
            "wave")
              MAX_PARALLEL=15
              BATCH_SIZE=50
              DELAY=5
              echo "ðŸŒŠ WAVE: Prioridade sequencial, paralelo por wave"
              ;;
            "batch")
              MAX_PARALLEL=10
              BATCH_SIZE=40
              DELAY=10
              echo "ðŸ“¦ BATCH: Waves + batches, delays maiores"
              ;;
            "mega")
              MAX_PARALLEL=5
              BATCH_SIZE=30
              DELAY=15
              echo "ðŸš€ MEGA: Multi-stage, rate limit aware"
              ;;
          esac
          
          echo ""
          echo "ðŸ“‹ ConfiguraÃ§Ã£o:"
          echo "   Strategy:     $STRATEGY"
          echo "   Max Parallel: $MAX_PARALLEL"
          echo "   Batch Size:   $BATCH_SIZE"
          echo "   Delay (s):    $DELAY"
          
          echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT
          echo "max_parallel=$MAX_PARALLEL" >> $GITHUB_OUTPUT
          echo "batch_size=$BATCH_SIZE" >> $GITHUB_OUTPUT
          echo "delay_between_batches=$DELAY" >> $GITHUB_OUTPUT
      
      - name: "ðŸ“Š Summary"
        run: |
          echo "## ðŸ§  Adaptive Orchestrator - Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ SDK Release" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** \`${{ steps.init.outputs.sdk_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation ID:** \`${{ steps.init.outputs.validation_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Dry Run:** ${{ steps.init.outputs.dry_run }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Consumer Distribution" >> $GITHUB_STEP_SUMMARY
          echo "| Priority | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ”´ Critical | ${{ steps.analyze.outputs.count_critical }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ  High | ${{ steps.analyze.outputs.count_high }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¡ Normal | ${{ steps.analyze.outputs.count_normal }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¢ Low | ${{ steps.analyze.outputs.count_low }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Total** | **${{ steps.analyze.outputs.total_consumers }}** |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Strategy Selected" >> $GITHUB_STEP_SUMMARY
          echo "- **Strategy:** \`${{ steps.plan.outputs.strategy }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Max Parallel:** ${{ steps.plan.outputs.max_parallel }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Batch Size:** ${{ steps.plan.outputs.batch_size }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Delay Between Batches:** ${{ steps.plan.outputs.delay_between_batches }}s" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2: DISPATCH CRITICAL (Sempre primeiro, mais rÃ¡pido)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  dispatch-critical:
    name: "ðŸ”´ Critical"
    runs-on: ubuntu-latest
    needs: analyze
    if: |
      needs.analyze.outputs.count_critical > 0 &&
      needs.analyze.outputs.dry_run != 'true'
    
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        consumer: ${{ fromJSON(needs.analyze.outputs.consumers_critical) }}
    
    steps:
      - name: "ðŸš€ ${{ matrix.consumer.name }}"
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.DISPATCH_TOKEN }}
          repository: ${{ matrix.consumer.repository }}
          event-type: ${{ matrix.consumer.event_type }}
          client-payload: |
            {
              "validation_id": "${{ needs.analyze.outputs.validation_id }}",
              "wave": "critical",
              "strategy": "${{ needs.analyze.outputs.strategy }}",
              "sdk": {"version": "${{ needs.analyze.outputs.sdk_version }}"},
              "consumer": {"name": "${{ matrix.consumer.name }}", "priority": "critical"},
              "callback": {"repository": "${{ github.repository }}", "event_type": "consumer.validation.complete"}
            }
        continue-on-error: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 3: DISPATCH HIGH
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  dispatch-high:
    name: "ðŸŸ  High"
    runs-on: ubuntu-latest
    needs: [analyze, dispatch-critical]
    if: |
      always() &&
      needs.analyze.outputs.count_high > 0 &&
      needs.analyze.outputs.dry_run != 'true'
    
    strategy:
      fail-fast: false
      max-parallel: ${{ fromJSON(needs.analyze.outputs.max_parallel) }}
      matrix:
        consumer: ${{ fromJSON(needs.analyze.outputs.consumers_high) }}
    
    steps:
      - name: "â³ Rate Limit"
        if: needs.analyze.outputs.strategy != 'direct'
        run: sleep ${{ needs.analyze.outputs.delay_between_batches }}
      
      - name: "ðŸš€ ${{ matrix.consumer.name }}"
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.DISPATCH_TOKEN }}
          repository: ${{ matrix.consumer.repository }}
          event-type: ${{ matrix.consumer.event_type }}
          client-payload: |
            {
              "validation_id": "${{ needs.analyze.outputs.validation_id }}",
              "wave": "high",
              "strategy": "${{ needs.analyze.outputs.strategy }}",
              "sdk": {"version": "${{ needs.analyze.outputs.sdk_version }}"},
              "consumer": {"name": "${{ matrix.consumer.name }}", "priority": "high"},
              "callback": {"repository": "${{ github.repository }}", "event_type": "consumer.validation.complete"}
            }
        continue-on-error: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 4: DISPATCH NORMAL (Bulk - usa estratÃ©gia adaptativa)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  dispatch-normal:
    name: "ðŸŸ¡ Normal"
    runs-on: ubuntu-latest
    needs: [analyze, dispatch-high]
    if: |
      always() &&
      needs.analyze.outputs.count_normal > 0 &&
      needs.analyze.outputs.dry_run != 'true'
    
    steps:
      - name: "â³ Rate Limit"
        run: sleep ${{ needs.analyze.outputs.delay_between_batches }}
      
      - name: "ðŸš€ Dispatch Normal Wave"
        env:
          DISPATCH_TOKEN: ${{ secrets.DISPATCH_TOKEN }}
        run: |
          CONSUMERS='${{ needs.analyze.outputs.consumers_normal }}'
          STRATEGY="${{ needs.analyze.outputs.strategy }}"
          SDK_VERSION="${{ needs.analyze.outputs.sdk_version }}"
          VALIDATION_ID="${{ needs.analyze.outputs.validation_id }}"
          BATCH_SIZE=${{ needs.analyze.outputs.batch_size }}
          DELAY=${{ needs.analyze.outputs.delay_between_batches }}
          
          TOTAL=$(echo "$CONSUMERS" | jq 'length')
          echo "ðŸ“Š Dispatching $TOTAL normal priority consumers"
          echo "ðŸ“‹ Strategy: $STRATEGY"
          
          DISPATCHED=0
          FAILED=0
          BATCH_NUM=0
          
          # Processa cada consumer
          INDEX=0
          for row in $(echo "$CONSUMERS" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${row} | base64 --decode | jq -r ${1}
            }
            
            NAME=$(_jq '.name')
            REPO=$(_jq '.repository')
            EVENT_TYPE=$(_jq '.event_type')
            
            # Batch delay (a cada BATCH_SIZE)
            if [ $INDEX -gt 0 ] && [ $((INDEX % BATCH_SIZE)) -eq 0 ]; then
              BATCH_NUM=$((BATCH_NUM + 1))
              echo "â³ Batch $BATCH_NUM complete, waiting ${DELAY}s..."
              sleep $DELAY
            fi
            
            # Dispatch com retry
            SUCCESS=false
            for attempt in 1 2 3; do
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer $DISPATCH_TOKEN" \
                "https://api.github.com/repos/$REPO/dispatches" \
                -d "{
                  \"event_type\": \"$EVENT_TYPE\",
                  \"client_payload\": {
                    \"validation_id\": \"$VALIDATION_ID\",
                    \"wave\": \"normal\",
                    \"strategy\": \"$STRATEGY\",
                    \"sdk\": {\"version\": \"$SDK_VERSION\"},
                    \"consumer\": {\"name\": \"$NAME\", \"priority\": \"normal\"},
                    \"callback\": {\"repository\": \"${{ github.repository }}\", \"event_type\": \"consumer.validation.complete\"}
                  }
                }")
              
              if [ "$HTTP_CODE" -eq 204 ] || [ "$HTTP_CODE" -eq 200 ]; then
                echo "âœ… $NAME"
                DISPATCHED=$((DISPATCHED + 1))
                SUCCESS=true
                break
              elif [ $attempt -lt 3 ]; then
                echo "âš ï¸ Retry $attempt for $NAME (HTTP $HTTP_CODE)"
                sleep $((attempt * 2))
              fi
            done
            
            if [ "$SUCCESS" != "true" ]; then
              echo "âŒ $NAME (failed after 3 attempts)"
              FAILED=$((FAILED + 1))
            fi
            
            # Small delay between requests
            sleep 0.3
            INDEX=$((INDEX + 1))
          done
          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸ“Š NORMAL WAVE COMPLETE"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Dispatched: $DISPATCHED"
          echo "Failed: $FAILED"
          echo "Total: $TOTAL"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 5: DISPATCH LOW
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  dispatch-low:
    name: "ðŸŸ¢ Low"
    runs-on: ubuntu-latest
    needs: [analyze, dispatch-normal]
    if: |
      always() &&
      needs.analyze.outputs.count_low > 0 &&
      needs.analyze.outputs.dry_run != 'true'
    
    steps:
      - name: "â³ Rate Limit"
        run: sleep ${{ needs.analyze.outputs.delay_between_batches }}
      
      - name: "ðŸš€ Dispatch Low Wave"
        env:
          DISPATCH_TOKEN: ${{ secrets.DISPATCH_TOKEN }}
        run: |
          CONSUMERS='${{ needs.analyze.outputs.consumers_low }}'
          SDK_VERSION="${{ needs.analyze.outputs.sdk_version }}"
          VALIDATION_ID="${{ needs.analyze.outputs.validation_id }}"
          BATCH_SIZE=${{ needs.analyze.outputs.batch_size }}
          DELAY=${{ needs.analyze.outputs.delay_between_batches }}
          
          TOTAL=$(echo "$CONSUMERS" | jq 'length')
          echo "ðŸ“Š Dispatching $TOTAL low priority consumers"
          
          DISPATCHED=0
          FAILED=0
          INDEX=0
          
          for row in $(echo "$CONSUMERS" | jq -r '.[] | @base64'); do
            _jq() {
              echo ${row} | base64 --decode | jq -r ${1}
            }
            
            NAME=$(_jq '.name')
            REPO=$(_jq '.repository')
            EVENT_TYPE=$(_jq '.event_type')
            
            # Batch delay
            if [ $INDEX -gt 0 ] && [ $((INDEX % BATCH_SIZE)) -eq 0 ]; then
              echo "â³ Batch pause, waiting ${DELAY}s..."
              sleep $DELAY
            fi
            
            # Dispatch
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer $DISPATCH_TOKEN" \
              "https://api.github.com/repos/$REPO/dispatches" \
              -d "{
                \"event_type\": \"$EVENT_TYPE\",
                \"client_payload\": {
                  \"validation_id\": \"$VALIDATION_ID\",
                  \"wave\": \"low\",
                  \"sdk\": {\"version\": \"$SDK_VERSION\"},
                  \"consumer\": {\"name\": \"$NAME\", \"priority\": \"low\"},
                  \"callback\": {\"repository\": \"${{ github.repository }}\", \"event_type\": \"consumer.validation.complete\"}
                }
              }")
            
            if [ "$HTTP_CODE" -eq 204 ]; then
              DISPATCHED=$((DISPATCHED + 1))
            else
              FAILED=$((FAILED + 1))
            fi
            
            sleep 0.3
            INDEX=$((INDEX + 1))
          done
          
          echo "ðŸ“Š Low wave: $DISPATCHED dispatched, $FAILED failed"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 6: FINAL REPORT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  report:
    name: "ðŸ“Š Report"
    runs-on: ubuntu-latest
    needs: [analyze, dispatch-critical, dispatch-high, dispatch-normal, dispatch-low]
    if: always()
    
    steps:
      - name: "ðŸ“Š Generate Report"
        run: |
          echo "## ðŸ§  Adaptive Orchestrator - Execution Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ SDK Release" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** \`${{ needs.analyze.outputs.sdk_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation ID:** \`${{ needs.analyze.outputs.validation_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Strategy Used" >> $GITHUB_STEP_SUMMARY
          echo "- **Strategy:** \`${{ needs.analyze.outputs.strategy }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Consumers:** ${{ needs.analyze.outputs.total_consumers }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒŠ Wave Results" >> $GITHUB_STEP_SUMMARY
          echo "| Wave | Count | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸ”´ Critical | ${{ needs.analyze.outputs.count_critical }} | ${{ needs.dispatch-critical.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ  High | ${{ needs.analyze.outputs.count_high }} | ${{ needs.dispatch-high.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¡ Normal | ${{ needs.analyze.outputs.count_normal }} | ${{ needs.dispatch-normal.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ðŸŸ¢ Low | ${{ needs.analyze.outputs.count_low }} | ${{ needs.dispatch-low.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "âœ… All waves dispatched. Check consumer repositories for validation results." >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 7: CALLBACK HANDLER (Separado)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  callback:
    name: "ðŸ“© Callback"
    runs-on: ubuntu-latest
    if: github.event.action == 'consumer.validation.complete'
    
    steps:
      - name: "ðŸ“© Process"
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸ“© CONSUMER CALLBACK RECEIVED"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Consumer: ${{ github.event.client_payload.consumer.name }}"
          echo "Status: ${{ github.event.client_payload.status }}"
          echo "Wave: ${{ github.event.client_payload.wave }}"
          echo "PR URL: ${{ github.event.client_payload.pr_url }}"
      
      - name: "ðŸ“Š Update Summary"
        run: |
          STATUS="${{ github.event.client_payload.status }}"
          if [ "$STATUS" == "success" ]; then
            echo "## âœ… Validation Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "## âŒ Validation Failed" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Consumer | ${{ github.event.client_payload.consumer.name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ github.event.client_payload.status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Wave | ${{ github.event.client_payload.wave }} |" >> $GITHUB_STEP_SUMMARY
          echo "| PR | ${{ github.event.client_payload.pr_url || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY
